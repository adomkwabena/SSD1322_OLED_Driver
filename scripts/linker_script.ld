/*
 *  File:       linker_script.ld
 *  Authour:    Adom Kwabena
 *
 *  References: Various online docs and ST's own linker script and 
 *  https://github.com/wntrblm/Castor_and_Pollux/blob/main/firmware/scripts/samd21g18a.ld
 *
 */

/*  
    The linker script combines input files into a single output file. The output
    file and each input files are in a special data format - object file format.
    The output file is also called an executable.
    
    Each object file has, among other things, a list of sections. Each section in 
    an object file has a name and a size. Most sections also have an associated 
    block of data, known as the section contents.
    
    A section may be marked as loadable, which means that the contents should be 
    loaded into memory when the output file is run. A section with no contents may
    be allocatable, which means that an area in memory should be set aside, but
    nothing in particulary should be loaded there (in some cases this memory must
    be zeroed out). A section which is neither loadable nor allocatable typically
    contains some sort of debugging information.
    
    Every loadable or allocatable output section has two addresses. The first is 
    the VMA, or virtual memory address. This is the address the section will have
    when the output file is run. The second is the LMA, or load memory address. This
    is the address at which the section will be loaded. In most cases the two addresses
    will be the same.
    
    An example of when they might be different is when a data section is loaded into ROM,
    and then copied into RAM when the program starts up (this technique is often used to 
    initialize global variables in a ROM based system). In this case the ROM address would
    be the LMA, and the RAM address would be the VMA.
*/

/* Entry point - this sets the first instruction to be executed in a program */
ENTRY(Reset_Handler)

/* Highest address of the user mode stack */
/* End of "RAM" type memory */
__stack_end__ = 0x2001FFFF;

/* Memory model/layout of the system */
/* r - readable, w - writeable, x - executable */
MEMORY
{
    FLASH   (rx)  : ORIGIN = 0x08000000,  LENGTH = 1024K
    CCMRAM  (rwx) : ORIGIN = 0x10000000,  LENGTH = 64K
    RAM     (rwx) : ORIGIN = 0x20000000,  LENGTH = 128K
}

/*
    The sections command tells the linker how to combine the input files into 
       an output ELF and where segments belong in memory.

       The linker takes a set of input files containing the "input sections" and 
       uses this to map them to "output sections" 
       which are placed in the output ELF file.

       While the most important sections to think about here are the ones that'll 
       be placed into the memory (segments) some sections are just placed in the 
       output ELF for debugging.

       Reference:
       https://sourceware.org/binutils/docs/ld/SECTIONS.html#SECTIONS
*/

/* 
    GCC generates three "flavors" of sections in object files:

    - .{section}: the basic section.
    - .{section}.*: sections generated by "-ffunction-sections" and
        "-fdata-sections" so that each function/data has a unique
        section.
    - .gnu.linkonce.{type}.*: sections generated by GCC so the
        linker can remove duplicates. Seems to be related to
        Vague Linking.

    Reference:
    https://gcc.gnu.org/onlinedocs/gcc/Vague-Linkage.html
*/

SECTIONS
{
    /* Contains ISR vector table*/
    /* 
        When defining the vector table in code you must use 
        "__attribute__((section(".isr_vector")))" (C) or use
        '.section .isr_vector,"a",%progbits' (asm) to tell GCC to place the
        vector table into the section named ".isr_vector" in the input file 
        so that the linker can find it.
 
        This segment must be 4-byte aligned as defined in the
        ARM ELF File Format specification
    */
    .isr_vector :
    {
        . = ALIGN(4);
        /* 
            Notice the use of "KEEP" here. To save on size, the firmware is 
            compiled with options that let GCC discard unused functions and 
            data ("--gc-sections"). Without "KEEP", the linker would throw 
            away the vector table!
         */
        KEEP(*(.isr_vector))
        . = ALIGN(4);
    } > FLASH

    /* 
        Put all code sections in flash memory hence the "*" before (.text)
    */
    .text :
    {
        . = ALIGN(4);
        *(.text)
        *(.text*)
        /* Glue ARM to Thumb code*/
        *(.glue_7)
        /* Glue Thumb to ARM code*/
        *(.glue_7t)
        *(.eh_frame)

        KEEP(*(.init))
        KEEP(*(.fini))

        . = ALIGN(4);
        __text_end__ = .;
    } > FLASH

    /* Read only data, this includes constants, strings, etc. */
    .rodata :
    {
        . = ALIGN(4);
        *(.rodata)
        *(.rodata*)
        . = ALIGN(4);
    } > FLASH

    /*
        ARM defines several special sections for exception handling. These are
        required for C++ and for C programs that try to examine backtraces.

        - exidx is used to contain index entries for stack unwinding.
        - extab names sections containing exception unwinding information.

        Essentially, each function that can throw an exception will
           have entries in the exidx and extab sections.

          References:
      - https://developer.arm.com/documentation/ihi0038/b/
      - https://stackoverflow.com/a/57463515
    */
    .ARM.extab :
    {
        . = ALIGN(4);
        *(.ARM.extab* .gnu.linkonce.armextab.*)
        . = ALIGN(4);
    } > FLASH

    .ARM :
    {
        . = ALIGN(4);
        __exidx_start = .;
        *(.ARM.exidx*)
        __exidx_end = .;
        . = ALIGN(4);
    } > FLASH

    .preinit_array :
    {
        . = ALIGN(4);
        PROVIDE_HIDDEN(__preinit_array_start = .);
        KEEP(*(.preinit_array*))
        PROVIDE_HIDDEN(__preinit_array_end = .);
        . = ALIGN(4);
    } > FLASH

    .init_array :
    {
        . = ALIGN(4);
        PROVIDE_HIDDEN(__init_array_start = .);
        KEEP(*(SORT(.init_array.*)))
        KEEP(*(.init_array*))
        PROVIDE_HIDDEN(__init_array_end = .);
        . = ALIGN(4);
    } > FLASH

    .fini_array :
    {
        . = ALIGN(4);
        PROVIDE_HIDDEN(__fini_array_start = .);
        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array*));
        PROVIDE_HIDDEN(__fini_aray_end = .);
        . = ALIGN(4);
    } > FLASH

    /* Used by the startup code to initialize data */
    __init_data_start__ = LOADADDR(.data);

    /*
        Initialized data

        The ".data" section includes mutable variables that have a default
        value and specially marked functions that should execute from RAM

        This data is stored in ROM but is referenced from RAM. The program
        or runtime must copy the data from ROM to RAM on reset.
    */
    .data :
    {
        . = ALIGN(4);
        __data_start__ = .;
        *(.data)
        *(.data*)
        . = ALIGN(4);
        __data_end__ = .;
    } > RAM AT> FLASH

    /*
        Declared but uninitialized data

        The start-up script zeros out the area of RAM starting with 
        "__bss_start__" and ending at "__bss_end__"
    */
    .bss :
    {
        . = ALIGN(4);
        __bss_start__ = .;
        *(.bss)
        *(.bss*)
        /* 
            The compiler may choose to allocate uninitialize gloabal variables
            as common blocks. This can be disabled with -fno-common if needed.
        */
        *(COMMON)
        . = ALIGN(4);
        __bss_end__ = .;
    } > RAM

    .ccm :
    {
        . = ALIGN(4);
        __ccm_start__ = .;
        *(.ccm)
        *(.ccm*)
        . = ALIGN(4);
        __ccm_end__ = .;
    } > CCMRAM
}
